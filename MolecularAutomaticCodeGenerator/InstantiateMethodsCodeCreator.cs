using System.Text;

namespace MolecularLib.CodeGenerator
{
    internal static class InstantiateMethodsCodeCreator
    {
        private const string Boilerplate = @"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the MolecularCodeGenerator.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
//
//     The generator code can be fount in this github repository:
//     
// </auto-generated>
//------------------------------------------------------------------------------";

        private const string License = @"/*  Copyright 2022 Gabriel Pasquale Rodrigues Scavone
*
*  Licensed under the Apache License, Version 2.0 (the ""License"");
*  you may not use this file except in compliance with the License.
*  You may obtain a copy of the License at
*
*      http://www.apache.org/licenses/LICENSE-2.0
*
*  Unless required by applicable law or agreed to in writing, software
*  distributed under the License is distributed on an ""AS IS"" BASIS,
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*  See the License for the specific language governing permissions and
*  limitations under the License.
*/";
        
        public const string MethodsFileName = "InstantiateWithArgsMethods.cs";
        public const string InterfacesFileName = "InstantiateWithArgsInterfaces.cs";
        private const string ClassDeclaration = "public static partial class Molecular";
        private const string Namespace = "MolecularLib";
        private const string MethodDeclaration = "public static T Instantiate";
        private const string MethodGenericTypeBaseRestriction = "where T : Object, ";
        private static readonly string[] Usings = { "UnityEngine" };
        private static readonly string[] MethodBaseSignatures = { 
            "T original", 
            "T original, Transform parent", 
            "T original, Vector3 position, Quaternion rotation",
            "T original, Vector3 position, Quaternion rotation, Transform parent"
        };

        private static readonly Dictionary<string, string[]> SignatureToParamNames = new()
        {
            { MethodBaseSignatures[0], new [] { "original" } },
            { MethodBaseSignatures[1], new [] { "original", "parent" }},
            { MethodBaseSignatures[2], new [] { "original", "position", "rotation" }},
            { MethodBaseSignatures[3], new [] { "original", "position", "rotation", "parent" }}
        };

        private const string GenericArgTypeName = "TArg";
        private const string GenericArgName = "arg";

        private const string InterfaceDeclaration = "public interface ";
        
        private const int MaxArgs = 12;
        
        internal static string CreateMethodsCode()
        {
            var builder = new StringBuilder();

            builder.Append(Boilerplate);
            builder.AppendLine();
            builder.Append(License);
            builder.AppendLine();
            builder.AppendLine();
            
            builder.AddUsing();
            builder.AppendLine();
            
            builder.AddNamespace();
            builder.AddClass();
            
            for (var i = 0; i <= MaxArgs; i++)
            {
                builder.AddMethod(i);
            }
            
            //Class closing
            builder.AppendIdentation(1);
            builder.AppendLine("}"); 
            //Namespace closing
            builder.AppendLine("}");
            
            return builder.ToString();
        }

        internal static string CreateInterfacesCode()
        {
            var builder = new StringBuilder();

            builder.Append(Boilerplate);
            builder.AppendLine();
            builder.Append(License);
            builder.AppendLine();
            builder.AppendLine();
            
            builder.AddNamespace();

            for (var i = 0; i <= MaxArgs; i++)
            {
                builder.AppendInterface(i);
            }
            
            //Namespace closing
            builder.AppendLine("}");

            return builder.ToString();
        }
        
        private static StringBuilder AddUsing(this StringBuilder builder)
        {
            foreach (var @using in Usings)
            {
                builder.AppendLine($"using {@using};");
            }
            return builder;
        }
        
        private static StringBuilder AddNamespace(this StringBuilder builder)
        {
            builder.AppendLine($"namespace {Namespace}");
            builder.AppendLine("{");
            return builder;
        }
        
        private static StringBuilder AddClass(this StringBuilder builder)
        {
            builder.AppendIdentation(1);
            builder.AppendLine($"{ClassDeclaration}");
            builder.AppendIdentation(1);
            builder.AppendLine("{");
            return builder;
        }

        private static StringBuilder AddMethod(this StringBuilder builder, int paramsCount)
        {
            const string instanceVarName = "instanceObj";
            const string asInterfaceVarName = "argsInstantiable";

            foreach (var signature in MethodBaseSignatures)
            {
                var identLevel = 2;
                builder.AppendInCodeDocumentation(paramsCount);
                
                // public static T Instantiate<T>(T original)
                builder.AppendIdentation(identLevel);
                builder.Append(MethodDeclaration);
                builder.Append("<T");
                for (var i = 0; i < paramsCount; i++)
                {
                    builder.Append(", ");
                    builder.Append($"{GenericArgTypeName}{i}");
                }            
                builder.Append('>');

                builder.Append('(');
                builder.Append(signature);
                for (var i = 0; i < paramsCount; i++)
                {
                    builder.Append(", ");
                    builder.Append($"{GenericArgTypeName}{i} {GenericArgName}{i}");
                }
                builder.Append(')');
                
                // where T : Object, IArgsInstantiable
                builder.Append(' ');
                builder.Append(MethodGenericTypeBaseRestriction);
                builder.AppendInterfaceSignature(paramsCount);
                builder.AppendLine();
                
                builder.AppendIdentation(identLevel);
                builder.AppendLine("{");
                identLevel++;
                
                // var instantiatedObj = Object.Instantiate(original);
                builder.AppendIdentation(identLevel);
                builder.AppendFormat("var {0} = Object.Instantiate", instanceVarName);
                builder.Append('(');
                for (var i = 0; i < SignatureToParamNames[signature].Length; i++)
                {
                    var paramName = SignatureToParamNames[signature][i];
                    builder.Append(paramName);
                    if (i < SignatureToParamNames[signature].Length - 1)
                    {
                        builder.Append(", ");
                    }
                }
                builder.AppendLine(");");
                builder.AppendLine();
                builder.AppendIdentation(identLevel);
                
                //if (instantiatedObj is IArgsInstantiable argsInstantiable)
                builder.AppendFormat("if ({0} is ", instanceVarName);
                builder.AppendInterfaceSignature(paramsCount);
                builder.AppendFormat(" {0})", asInterfaceVarName);
                builder.AppendLine();
                
                identLevel++;
                builder.AppendIdentation(identLevel);
                
                // argsInstantiable.Initialize();
                builder.AppendFormat("{0}.", asInterfaceVarName);

                builder.AppendInitializeMethod(paramsCount);
                
                builder.AppendLine();

                identLevel--;
                builder.AppendIdentation(identLevel);
                
                //return instantiatedObj;
                builder.AppendFormat("return {0};", instanceVarName);
                builder.AppendLine();
                
                identLevel--;
                builder.AppendIdentation(identLevel);
                builder.AppendLine("}");
                
                builder.AppendLine();
            }

            return builder;
        }
        
        private static StringBuilder AppendIdentation(this StringBuilder builder, int identation)
        {
            for (var i = 0; i < identation; i++)
            {
                builder.Append("    ");
            }
            return builder;
        }
        
        private static StringBuilder AppendInterfaceSignature(this StringBuilder builder, int paramsCount, bool addIn = false)
        {
            builder.Append("IArgsInstantiable");
            if (paramsCount <= 0) return builder;
            
            builder.Append('<');
            for (var i = 0; i < paramsCount; i++)
            {
                if (addIn) builder.Append("in ");
                builder.Append($"{GenericArgTypeName}{i}");
                if (i < paramsCount - 1)
                {
                    builder.Append(", ");
                }
            }
            builder.Append('>');

            return builder;
        }

        private static StringBuilder AppendInCodeDocumentation(this StringBuilder builder, int argsCount)
        {
            builder.AppendIdentation(2);
            builder.AppendLine("/// <summary>)");
            builder.AppendIdentation(2);
            builder.AppendLine($"/// Instantiates a Object that derives from IArgsInstantiable with {argsCount} parameters and calls the initialize function");
            builder.AppendIdentation(2);
            builder.AppendLine("/// </summary>");

            return builder;
        }

        private static StringBuilder AppendInitializeMethod(this StringBuilder builder, int paramsCount, bool addGenericType = false)
        {
            builder.Append("Initialize(");
                
            for (var i = 0; i < paramsCount; i++)
            {
                if (addGenericType) builder.Append($"{GenericArgTypeName}{i} ");
                builder.Append($"{GenericArgName}{i}");
                if (i < paramsCount - 1)
                {
                    builder.Append(", ");
                }
            }
                
            builder.AppendLine(");");
            return builder;
        }
        
        private static StringBuilder AppendInterface(this StringBuilder builder, int argsCount)
        {
            // public interface IArgsInstantiable
            builder.AppendIdentation(1);
            builder.Append(InterfaceDeclaration);
            builder.AppendInterfaceSignature(argsCount, true);
            
            // {
            builder.AppendLine();
            builder.AppendIdentation(1);
            builder.AppendLine("{");
            
            // public void Initialize();
            builder.AppendIdentation(2);
            builder.Append("public void ");
            builder.AppendInitializeMethod(argsCount, true);
            builder.AppendIdentation(1);
            
            // }
            builder.AppendLine("}");
            builder.AppendLine();

            return builder;
        }
        
    }
}