/*  Copyright 2022 Gabriel Pasquale Rodrigues Scavone
*
*  Licensed under the Apache License, Version 2.0 (the ""License"");
*  you may not use this file except in compliance with the License.
*  You may obtain a copy of the License at
*
*      http://www.apache.org/licenses/LICENSE-2.0
*
*  Unless required by applicable law or agreed to in writing, software
*  distributed under the License is distributed on an ""AS IS"" BASIS,
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*  See the License for the specific language governing permissions and
*  limitations under the License.
*/

using System.Text;

namespace MolecularLib.CodeGenerator
{
    internal static class InstantiateMethodsCodeCreator
    {
        private const string Boilerplate = @"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the MolecularCodeGenerator.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
//
//     The generator code can be found here, in this github repository:
//     https://github.com/Heymity/MolecularLibCore/tree/main/MolecularAutomaticCodeGenerator
// </auto-generated>
//------------------------------------------------------------------------------";
        
        public const string MethodsFileName = "InstantiateWithArgsMethods.cs";
        public const string InterfacesFileName = "InstantiateWithArgsInterfaces.cs";
        private const string ClassDeclaration = "public static partial class Molecular";
        private const string Namespace = "MolecularLib";
        private const string MethodDeclaration = "public static T Instantiate";
        private const string MethodGenericTypeBaseRestriction = "where T : Object, ";
        private static readonly string[] Usings = { "UnityEngine" };
        private static readonly string[] MethodBaseSignatures = { 
            "T original", 
            "T original, Transform parent", 
            "T original, Vector3 position, Quaternion rotation",
            "T original, Vector3 position, Quaternion rotation, Transform parent"
        };

        private static readonly Dictionary<string, string[]> SignatureToParamNames = new()
        {
            { MethodBaseSignatures[0], new [] { "original" } },
            { MethodBaseSignatures[1], new [] { "original", "parent" }},
            { MethodBaseSignatures[2], new [] { "original", "position", "rotation" }},
            { MethodBaseSignatures[3], new [] { "original", "position", "rotation", "parent" }}
        };

        private const string GenericArgTypeName = "TArg";
        private const string GenericArgName = "arg";

        private const string InterfaceDeclaration = "public interface ";
        
        private const int MaxArgs = 10;
        
        internal static string CreateMethodsCode()
        {
            var builder = new StringBuilder();

            builder
                .Append(Boilerplate)
                .AppendLine()
                .AppendLine()
                .AppendLine()
            
                .AddUsing()
                .AppendLine()
            
                .AddNamespace()
                .AddClass();
            
            for (var i = 0; i <= MaxArgs; i++)
            {
                builder.AddMethod(i);
            }
            
            //Class closing
            builder.AppendIdentation(1).AppendLine("}"); 
            //Namespace closing
            builder.AppendLine("}");
            
            return builder.ToString();
        }

        internal static string CreateInterfacesCode()
        {
            var builder = new StringBuilder();

            builder
                .Append(Boilerplate)
                .AppendLine()
                .Append(License)
                .AppendLine()
                .AppendLine()
            
                .AddNamespace();

            for (var i = 0; i <= MaxArgs; i++)
            {
                builder.AppendInterface(i);
            }
            
            //Namespace closing
            builder.AppendLine("}");

            return builder.ToString();
        }
        
        private static StringBuilder AddUsing(this StringBuilder builder)
        {
            foreach (var @using in Usings)
            {
                builder.AppendLine($"using {@using};");
            }
            return builder;
        }
        
        private static StringBuilder AddNamespace(this StringBuilder builder)
        {
            return builder
                .AppendLine($"namespace {Namespace}")
                .AppendLine("{");
        }
        
        private static StringBuilder AddClass(this StringBuilder builder)
        {
            return builder
                .AppendIdentation(1)
                    .AppendLine($"{ClassDeclaration}")
                .AppendIdentation(1)
                    .AppendLine("{");
        }

        private static StringBuilder AddMethod(this StringBuilder builder, int paramsCount)
        {
            const string instanceVarName = "instanceObj";
            const string asInterfaceVarName = "argsInstantiable";

            foreach (var signature in MethodBaseSignatures)
            {
                var identLevel = 2;
                builder.AppendInCodeDocumentation(paramsCount);
                
                // public static T Instantiate<T>(T original)
                builder.AppendIdentation(identLevel).Append(MethodDeclaration).Append("<T");
                
                for (var i = 0; i < paramsCount; i++)
                {
                    builder.Append(", ");
                    builder.Append($"{GenericArgTypeName}{i}");
                }            
                
                builder.Append('>').Append('(').Append(signature);
                
                for (var i = 0; i < paramsCount; i++)
                {
                    builder.Append($", {GenericArgTypeName}{i} {GenericArgName}{i}");
                }
                builder.Append(')');
                
                // where T : Object, IArgsInstantiable
                builder
                    .Append(' ')
                    .Append(MethodGenericTypeBaseRestriction)
                    .AppendInterfaceSignature(paramsCount)
                    .AppendLine()
                
                    .AppendIdentation(identLevel)
                    .AppendLine("{");
                
                identLevel++;
                
                // var instantiatedObj = Object.Instantiate(original);
                builder
                    .AppendIdentation(identLevel)
                    .AppendFormat("var {0} = Object.Instantiate", instanceVarName)
                    .Append('(');
                
                for (var i = 0; i < SignatureToParamNames[signature].Length; i++)
                {
                    var paramName = SignatureToParamNames[signature][i];
                    builder.Append(paramName);
                    if (i < SignatureToParamNames[signature].Length - 1)
                    {
                        builder.Append(", ");
                    }
                }
                builder
                    .AppendLine(");")
                    .AppendLine()
                    
                    //if (instantiatedObj is IArgsInstantiable argsInstantiable)
                    .AppendIdentation(identLevel).AppendFormat("if ({0} is ", instanceVarName)
                    .AppendInterfaceSignature(paramsCount)
                    .AppendFormat(" {0})", asInterfaceVarName)
                    .AppendLine();
                
                identLevel++;

                // argsInstantiable.Initialize();
                builder
                    .AppendIdentation(identLevel)
                    .AppendFormat("{0}.", asInterfaceVarName)
                    .AppendInitializeMethod(paramsCount)
                    .AppendLine();

                identLevel--;

                //return instantiatedObj;
                builder
                    .AppendIdentation(identLevel)
                    .AppendFormat("return {0};", instanceVarName)
                    .AppendLine();
                
                identLevel--;
                builder
                    .AppendIdentation(identLevel)
                    .AppendLine("}")
                    .AppendLine();
            }

            return builder;
        }
        
        private static StringBuilder AppendIdentation(this StringBuilder builder, int identation)
        {
            for (var i = 0; i < identation; i++)
            {
                builder.Append("    ");
            }
            return builder;
        }
        
        private static StringBuilder AppendInterfaceSignature(this StringBuilder builder, int paramsCount, bool addIn = false)
        {
            builder.Append("IArgsInstantiable");
            if (paramsCount <= 0) return builder;
            
            builder.Append('<');
            for (var i = 0; i < paramsCount; i++)
            {
                if (addIn) builder.Append("in ");
                builder.Append($"{GenericArgTypeName}{i}");
                if (i < paramsCount - 1)
                {
                    builder.Append(", ");
                }
            }
            builder.Append('>');

            return builder;
        }

        private static StringBuilder AppendInCodeDocumentation(this StringBuilder builder, int argsCount)
        {
            builder.AppendIdentation(2).AppendLine("/// <summary>)");
            builder.AppendIdentation(2).AppendLine($"/// Instantiates a Object that derives from IArgsInstantiable with {argsCount} parameters and calls the initialize function");
            builder.AppendIdentation(2).AppendLine("/// </summary>");

            return builder;
        }

        private static StringBuilder AppendInitializeMethod(this StringBuilder builder, int paramsCount, bool addGenericType = false)
        {
            builder.Append("Initialize(");
                
            for (var i = 0; i < paramsCount; i++)
            {
                if (addGenericType) builder.Append($"{GenericArgTypeName}{i} ");
                builder.Append($"{GenericArgName}{i}");
                if (i < paramsCount - 1)
                {
                    builder.Append(", ");
                }
            }
                
            builder.AppendLine(");");
            return builder;
        }
        
        private static StringBuilder AppendInterface(this StringBuilder builder, int argsCount)
        {
            // public interface IArgsInstantiable
            return builder
                .AppendIdentation(1)
                .Append(InterfaceDeclaration)
                .AppendInterfaceSignature(argsCount, true)
                // {
                .AppendLine()
                .AppendIdentation(1)
                .AppendLine("{")
                    // public void Initialize();
                    .AppendIdentation(2)
                    .Append("public void ")
                    .AppendInitializeMethod(argsCount, true)
                    .AppendIdentation(1)
                // }
                .AppendLine("}")
                .AppendLine();
        }
        
    }
}